%========================================================================
% CryoGrid FORCING processing class load_and_apply_TRANSFORM
% use either FORCING classes based on FORCING_base_carrier_reference and
% fit the transformation during during runtime, or load ready-made files
% that are generated by fit_TRANSFORM and saved. 
%
% Authors:
% S. Westermann, December 2022
%
%========================================================================

classdef load_and_apply_TRANSFORM < matlab.mixin.Copyable %makes the TRANSFORM object
    
    properties
        CONST
        PARA
        STATVAR
        TEMP
    end
    
    methods
        function proc = provide_PARA(proc)
            proc.PARA.transform_forcing_class = [];  %must be filled
            proc.PARA.transform_forcing_class_index = [];
            
            proc.PARA.transform_folders = []; %use result_path if empty, possible to only provide a single string, i.e. not H_LIST
            proc.PARA.transform_files = []; %provide H_LIST
            
            proc.PARA.spatial_variable = [];
            proc.PARA.spatial_scale_equal_weight = [];
        end
        
        
        function proc = provide_CONST(proc)

        end
        
        
        function proc = provide_STATVAR(proc)
            
        end
        
        
        function proc = finalize_init(proc, tile)
            %uif empty use the result_path, if not a cell array make it a
            %cell array with the correct number of entries
            if  ~iscell(proc.PARA.transform_folders) && iscell(proc.PARA.transform_files)
                if isempty(proc.PARA.transform_folders) || sum(isnan(proc.PARA.transform_folders))>0
                    transform_folder = [tile.PARA.result_path tile.PARA.run_name '/'];
                else
                    transform_folder = proc.PARA.transform_folders;
                end
                 proc.PARA.transform_folders = {};
                 for i=1:size(proc.PARA.transform_files,1)
                     proc.PARA.transform_folders{i,1} = transform_folder;
                 end
            end
        end
        
        
        function forcing = process(proc, forcing, tile)
            
            if isempty(proc.PARA.spatial_variable) || ~iscell(proc.PARA.spatial_variable)
                proc.PARA.spatial_variable ={'altitude'};
                proc.PARA.spatial_scale_equal_weight = 50;
            end
            
            spatial_scale_variable = [];
            transform_forcing_class = {};
            %load the FORCING transform classes that are used to
            %bias correct online
            if ~isempty(proc.PARA.transform_forcing_class_index) && sum(isnan(proc.PARA.transform_forcing_class_index))==0
                %1. calculate weights for the different transform classes
                for j=1:size(proc.PARA.transform_forcing_class,1)
                    transform_forcing_class{j,1} = copy(tile.RUN_INFO.PPROVIDER.CLASSES.(proc.PARA.transform_forcing_class{j,1}){proc.PARA.transform_forcing_class_index(j,1),1});
                    transform_forcing_class{j,1} = finalize_init(transform_forcing_class{j,1}, tile);
                    scale_vars = [];
                    for i=1:size(proc.PARA.spatial_variable,1)
                        if ~strcmp(proc.PARA.spatial_variable{i,1}, 'distance')
                            scale_vars = [scale_vars transform_forcing_class{j,1}.SPATIAL.STATVAR.(proc.PARA.spatial_variable{i,1}) - forcing.SPATIAL.STATVAR.(proc.PARA.spatial_variable{i,1})];
                        else
                            dist = distance(transform_forcing_class{j,1}.SPATIAL.STATVAR.latitude,transform_forcing_class{j,1}.SPATIAL.STATVAR.longitude,forcing.SPATIAL.STATVAR.latitude, forcing.SPATIAL.STATVAR.longitude, wgs84Ellipsoid("m"))./1000; %in km
                            scale_vars = [scale_vars dist];
                        end
                    end
                    spatial_scale_variable = [spatial_scale_variable; scale_vars];
                end
            end
            %load the classes that are stored in files
            if ~isempty(proc.PARA.transform_files) && iscell(proc.PARA.transform_files)
                %1. calculate weights for the different transform classes
                offset = size(transform_forcing_class,1);
                for j=1:size(proc.PARA.transform_files,1)
                    temp=load([proc.PARA.transform_folders{j,1} proc.PARA.transform_files{j,1}]);
            
                    transform_forcing_class{j+offset,1} = FORCING_base_carrier_reference();
                    transform_forcing_class{j+offset,1}.TRANSFORM = temp.transform;
                    transform_forcing_class{j+offset,1}.SPATIAL = temp.spatial;                    
                    scale_vars = [];
                    for i=1:size(proc.PARA.spatial_variable,1)
                        if ~strcmp(proc.PARA.spatial_variable{i,1}, 'distance')
                            scale_vars = [scale_vars transform_forcing_class{j+offset,1}.SPATIAL.STATVAR.(proc.PARA.spatial_variable{i,1}) - forcing.SPATIAL.STATVAR.(proc.PARA.spatial_variable{i,1})];
                        else
                            dist = distance(transform_forcing_class{j+offset,1}.SPATIAL.STATVAR.latitude, transform_forcing_class{j+offset,1}.SPATIAL.STATVAR.longitude, forcing.SPATIAL.STATVAR.latitude, forcing.SPATIAL.STATVAR.longitude, wgs84Ellipsoid("m"))./1000; %in km
                            scale_vars = [scale_vars dist];
                        end
                    end
                    spatial_scale_variable = [spatial_scale_variable; scale_vars];
                end
            end
            
            
            %set the value to spatial_scale_equal_weight if smaller 
            spatial_scale_variable = (double(spatial_scale_variable>=0) - double(spatial_scale_variable<0)) .*  max(abs(spatial_scale_variable), repmat(proc.PARA.spatial_scale_equal_weight',size(spatial_scale_variable,1),1));

            weights = spatial_scale_variable ./ repmat(proc.PARA.spatial_scale_equal_weight', size(spatial_scale_variable,1),1);

            %penalize weights outside the range of the values
            weights_reduced = weights ./ max(min(abs(weights),[], 1), proc.PARA.spatial_scale_equal_weight');
            for i=1:size(weights,2)
                if sum(weights(:,i) <= 0) == 0
                    weights(weights_reduced(:,i) > 1,i) = weights(weights_reduced(:,i) > 1,i) .*10;
                elseif  sum(weights(:,i) >= 0) == 0
                    weights(weights_reduced(:,i) < -1,i) = weights(weights_reduced(:,i) < -1,i) .*10;
                end
            end
            
            weights = 1./sum(weights.^2,2);
            weights = weights./sum(weights);
            weights(weights<0.1) = 0;
            weights = weights./sum(weights);
            
            %multiply forcing.DATA with  weights

            modified_forcing = forcing.CARRIER.DATA;
            for j=1:size(transform_forcing_class,1)            
                forcing.DATA = forcing.CARRIER.DATA;
                for i=1:size(transform_forcing_class{j,1}.TRANSFORM,1)
                    forcing.DATA.(transform_forcing_class{j,1}.TRANSFORM{i,1}.PARA.variable) = apply_transform(transform_forcing_class{j,1}.TRANSFORM{i,1}, forcing, tile);
                end
                %multiply with  weights and add to modified_forcing
                variables = fieldnames(forcing.DATA);
                for i=1:size(variables,1)
                    if ~strcmp('timeForcing', variables{i,1})
                        if j==1
                            modified_forcing.(variables{i,1}) = weights(j,1) .* forcing.DATA.(variables{i,1});
                        else
                            modified_forcing.(variables{i,1}) = modified_forcing.(variables{i,1}) + weights(j,1) .* forcing.DATA.(variables{i,1});
                        end
                    end
                end
            end
            
            forcing.DATA = modified_forcing;
        end
        
        
                %-------------param file generation-----
%         function post_proc = param_file_info(post_proc)
%             post_proc = provide_PARA(post_proc);
% 
%             post_proc.PARA.STATVAR = [];
%             post_proc.PARA.class_category = 'FORCING POST_PROCESSING';
%             post_proc.PARA.options = [];
%             
%             post_proc.PARA.eliminate_fraction = [];
%             post_proc.PARA.survive_fraction = [];
%                         
%             post_proc.PARA.default_value.window_size = {7};
%             post_proc.PARA.comment.window_size = {'window size in days within which precipitation is reallocated'};
%             
%             post_proc.PARA.default_value.eliminate_fraction = {0.5};
%             post_proc.PARA.comment.eliminate_fraction = {'fraction of smallest precipitation events (= timestamps with precipitation) that is reallocated to larger events'};
%             
%             post_proc.PARA.default_value.survive_fraction = {0.5};  
%             post_proc.PARA.comment.survive_fraction = {'fraction of largest precipitation events (= timestamps with precipitation) that the small events are reallocated to'};
%             
%         end
        
    end
    
end

